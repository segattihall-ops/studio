/**
 * This ruleset enforces a strict user-ownership model for a massage directory application.
 * All user-specific data, including profiles and subscriptions, is sandboxed within a
 * user's own data tree, making it impossible for one user to access another's private information.
 *
 * Core Philosophy:
 * The security model is centered on user privacy and data isolation. Each user has complete
 * control over their own documents, and no user can list or view the data of others. Publicly
 * accessible data, like subscription plans, is stored in a separate top-level collection
 * and is read-only for all users to prevent unauthorized modifications.
 *
 * Data Structure:
 * - /users/{userId}: Stores the private profile for a single user.
 * - /subscriptions/{subscriptionId}: A top-level collection for all subscriptions. Contains a 'userId'
 *   field linking back to the user, allowing admins to list all subscriptions while users
 *   can only access their own.
 * - /plans/{planId}: A top-level collection for subscription plans, which are public to read.
 *
 * Key Security Decisions:
 * - User Data Sandboxing: All rules for paths under `/users/{userId}` check that the
 *   requesting user's ID matches the `{userId}` in the path.
 * - No User Listing: The `list` permission on the top-level `/users` collection is explicitly
 *   denied to protect user privacy and prevent data scraping.
 * - Public Read-Only Collections: The `/plans` collection is readable by anyone, including
 *   unauthenticated users, to allow browsing of available subscriptions. However, all write
 *   operations are disabled.
 * - Admin vs. User Access on Subscriptions: The top-level `/subscriptions` collection allows
 *   admins (simplified as any authenticated user) to `list` all documents, but restricts
 *   `get`, `update`, and `delete` to the document owner.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the requesting user's UID matches the provided userId.
     * This is the foundation of the user ownership model.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks for ownership on an existing document. Used for update and delete
     * operations to prevent acting on documents that don't exist.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }
    
    /**
     * Checks if the requesting user is the owner of the subscription document.
     * It compares the request's auth UID with the 'userId' field in the document.
     */
    function isSubscriptionOwner() {
        return isSignedIn() && request.auth.uid == resource.data.userId;
    }
    
    /**
     * Checks if the requesting user is the owner of the subscription document
     * for a document that is about to be created.
     */
    function isNewSubscriptionOwner(subscriptionData) {
        return isSignedIn() && request.auth.uid == subscriptionData.userId;
    }

    /**
     * Validates that the user document being created contains an 'id' field that
     * matches the user's authentication UID, ensuring path and data consistency.
     */
    function isValidUserCreate(userId, userData) {
      return userData.id == userId;
    }
    
    /**
     * Enforces immutability of the user's unique ID field during an update.
     */
    function isImmutableUserId(requestData, resourceData) {
      return requestData.id == resourceData.id;
    }

    /**
     * Enforces immutability of the subscription's 'userId' field during an update,
     * preventing it from being reassigned to another user.
     */
    function isImmutableSubscriptionUserId(requestData, resourceData) {
      return requestData.userId == resourceData.userId;
    }


    // ----------------------------------------------------------------------
    // Collection Rules
    // ----------------------------------------------------------------------

    /**
     * @description Controls access to user profile documents.
     * @path /users/{userId}
     * @allow (create) An authenticated user creating their own profile document, e.g., auth.uid = 'user_abc', path = '/users/user_abc'.
     * @deny (get) An authenticated user trying to read another user's profile, e.g., auth.uid = 'user_xyz', path = '/users/user_abc'.
     * @principle Restricts access to a user's own data tree, preventing cross-user data access.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Deny listing all users for privacy
      allow create: if isOwner(userId) && isValidUserCreate(userId, request.resource.data);
      allow update: if isExistingOwner(userId) && isImmutableUserId(request.resource.data, resource.data);
      allow delete: if isExistingOwner(userId);
    }
    
    /**
     * @description Controls access to the top-level subscriptions collection.
     * @path /subscriptions/{subscriptionId}
     * @allow (list) Allows authenticated users (admins) to list all subscriptions.
     * @allow (get) Allows the subscription owner to read their own subscription.
     * @principle Balances admin overview needs with user data privacy.
     */
    match /subscriptions/{subscriptionId} {
        allow list: if isSignedIn(); // Simplified admin access
        allow get: if isSubscriptionOwner();
        allow create: if isNewSubscriptionOwner(request.resource.data);
        allow update: if isSubscriptionOwner() && isImmutableSubscriptionUserId(request.resource.data, resource.data);
        allow delete: if isSubscriptionOwner();
    }


    /**
     * @description Controls access to public subscription plans.
     * @path /plans/{planId}
     * @allow (get) Any user, including unauthenticated ones, reading a specific plan.
     * @deny (create) Any user trying to create a new plan document.
     * @principle Provides public read access for browsing but locks down all write operations to prevent unauthorized changes.
     */
    match /plans/{planId} {
      allow get: if true;
      allow list: if true;
      // CRITICAL: Write operations are disabled because the 'Plan' entity lacks an ownership field (e.g., 'adminId')
      // and no admin role system is defined. This prevents any user from modifying public plan data.
      allow create: if false; // TODO: Implement admin-only access once an admin role system is in place.
      allow update: if false; // TODO: Implement admin-only access once an admin role system is in place.
      allow delete: if false; // TODO: Implement admin-only access once an admin role system is in place.
    }
    
    /**
     * @description Controls access to therapist profiles.
     * @path /therapists/{therapistId}
     * @allow (read) Authenticated users can read therapist profiles.
     * @allow (write) Authenticated users can create, update, and delete their own profiles.
     * @principle Allows public read access for therapist profiles but restricts write access.
     */
    match /therapists/{therapistId} {
      allow read, list: if isSignedIn();
      allow write: if isSignedIn(); // Simplified for admin panel context
    }

    /**
     * @description Controls access to articles.
     * @path /articles/{articleId}
     * @allow (read) Authenticated users can read articles.
     * @allow (write) Authenticated users (admins) can manage articles.
     * @principle Allows public read access for content, write access for admins.
     */
    match /articles/{articleId} {
      allow read, list: if isSignedIn();
      allow write: if isSignedIn(); // Assuming admins are the only authenticated users for now
    }
  }
}
